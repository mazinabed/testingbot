{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Telegraf = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst http = require(\"http\");\n\nconst https = require(\"https\");\n\nconst util = require(\"util\");\n\nconst composer_1 = require(\"./composer\");\n\nconst compact_1 = require(\"./core/helpers/compact\");\n\nconst context_1 = require(\"./context\");\n\nconst debug_1 = require(\"debug\");\n\nconst webhook_1 = require(\"./core/network/webhook\");\n\nconst polling_1 = require(\"./core/network/polling\");\n\nconst p_timeout_1 = require(\"p-timeout\");\n\nconst telegram_1 = require(\"./telegram\");\n\nconst url_1 = require(\"url\");\n\nconst debug = (0, debug_1.default)('telegraf:main');\nconst DEFAULT_OPTIONS = {\n  telegram: {},\n  handlerTimeout: 90000,\n  contextType: context_1.default\n};\n\nfunction always(x) {\n  return () => x;\n}\n\nconst anoop = always(Promise.resolve());\n\nclass Telegraf extends composer_1.Composer {\n  constructor(token, options) {\n    super();\n    this.context = {};\n\n    this.handleError = (err, ctx) => {\n      // set exit code to emulate `warn-with-error-code` behavior of\n      // https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode\n      // to prevent a clean exit despite an error being thrown\n      process.exitCode = 1;\n      console.error('Unhandled error while processing', ctx.update);\n      throw err;\n    }; // @ts-expect-error Trust me, TS\n\n\n    this.options = { ...DEFAULT_OPTIONS,\n      ...(0, compact_1.compactOptions)(options)\n    };\n    this.telegram = new telegram_1.default(token, this.options.telegram);\n    debug('Created a `Telegraf` instance');\n  }\n\n  get token() {\n    return this.telegram.token;\n  }\n  /** @deprecated use `ctx.telegram.webhookReply` */\n\n\n  set webhookReply(webhookReply) {\n    this.telegram.webhookReply = webhookReply;\n  }\n\n  get webhookReply() {\n    return this.telegram.webhookReply;\n  }\n  /**\n   * _Override_ error handling\n   */\n\n\n  catch(handler) {\n    this.handleError = handler;\n    return this;\n  }\n\n  webhookCallback() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    return (0, webhook_1.default)(path, (update, res) => this.handleUpdate(update, res));\n  }\n\n  startPolling() {\n    let allowedUpdates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    this.polling = new polling_1.Polling(this.telegram, allowedUpdates);\n    this.polling.loop(async updates => {\n      await this.handleUpdates(updates);\n    });\n  }\n\n  startWebhook(hookPath, tlsOptions, port, host, cb) {\n    const webhookCb = this.webhookCallback(hookPath);\n    const callback = typeof cb === 'function' ? (req, res) => webhookCb(req, res, () => cb(req, res)) : webhookCb;\n    this.webhookServer = tlsOptions != null ? https.createServer(tlsOptions, callback) : http.createServer(callback);\n    this.webhookServer.listen(port, host, () => {\n      debug('Webhook listening on port: %s', port);\n    });\n    return this;\n  }\n\n  secretPathComponent() {\n    return crypto.createHash('sha3-256').update(this.token).update(process.version) // salt\n    .digest('hex');\n  }\n  /**\n   * @see https://github.com/telegraf/telegraf/discussions/1344#discussioncomment-335700\n   */\n\n\n  async launch() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a, _b, _c;\n\n    debug('Connecting to Telegram');\n    (_a = this.botInfo) !== null && _a !== void 0 ? _a : this.botInfo = await this.telegram.getMe();\n    debug(`Launching @${this.botInfo.username}`);\n\n    if (config.webhook === undefined) {\n      await this.telegram.deleteWebhook({\n        drop_pending_updates: config.dropPendingUpdates\n      });\n      this.startPolling(config.allowedUpdates);\n      debug('Bot started with long polling');\n      return;\n    }\n\n    if (typeof config.webhook.domain !== 'string' && typeof config.webhook.hookPath !== 'string') {\n      throw new Error('Webhook domain or webhook path is required');\n    }\n\n    let domain = (_b = config.webhook.domain) !== null && _b !== void 0 ? _b : '';\n\n    if (domain.startsWith('https://') || domain.startsWith('http://')) {\n      domain = new url_1.URL(domain).host;\n    }\n\n    const hookPath = (_c = config.webhook.hookPath) !== null && _c !== void 0 ? _c : `/telegraf/${this.secretPathComponent()}`;\n    const {\n      port,\n      host,\n      tlsOptions,\n      cb\n    } = config.webhook;\n    this.startWebhook(hookPath, tlsOptions, port, host, cb);\n\n    if (!domain) {\n      debug('Bot started with webhook');\n      return;\n    }\n\n    await this.telegram.setWebhook(`https://${domain}${hookPath}`, {\n      drop_pending_updates: config.dropPendingUpdates,\n      allowed_updates: config.allowedUpdates,\n      ip_address: config.webhook.ipAddress,\n      max_connections: config.webhook.maxConnections\n    });\n    debug(`Bot started with webhook @ https://${domain}`);\n  }\n\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unspecified';\n\n    var _a, _b;\n\n    debug('Stopping bot... Reason:', reason); // https://github.com/telegraf/telegraf/pull/1224#issuecomment-742693770\n\n    if (this.polling === undefined && this.webhookServer === undefined) {\n      throw new Error('Bot is not running!');\n    }\n\n    (_a = this.webhookServer) === null || _a === void 0 ? void 0 : _a.close();\n    (_b = this.polling) === null || _b === void 0 ? void 0 : _b.stop();\n  }\n\n  handleUpdates(updates) {\n    if (!Array.isArray(updates)) {\n      throw new TypeError(util.format('Updates must be an array, got', updates));\n    }\n\n    return Promise.all(updates.map(update => this.handleUpdate(update)));\n  }\n\n  async handleUpdate(update, webhookResponse) {\n    var _a, _b;\n\n    (_a = this.botInfo) !== null && _a !== void 0 ? _a : this.botInfo = (debug('Update %d is waiting for `botInfo` to be initialized', update.update_id), await ((_b = this.botInfoCall) !== null && _b !== void 0 ? _b : this.botInfoCall = this.telegram.getMe()));\n    debug('Processing update', update.update_id);\n    const tg = new telegram_1.default(this.token, this.telegram.options, webhookResponse);\n    const TelegrafContext = this.options.contextType;\n    const ctx = new TelegrafContext(update, tg, this.botInfo);\n    Object.assign(ctx, this.context);\n\n    try {\n      await (0, p_timeout_1.default)(Promise.resolve(this.middleware()(ctx, anoop)), this.options.handlerTimeout);\n    } catch (err) {\n      return await this.handleError(err, ctx);\n    } finally {\n      if ((webhookResponse === null || webhookResponse === void 0 ? void 0 : webhookResponse.writableEnded) === false) {\n        webhookResponse.end();\n      }\n\n      debug('Finished processing update', update.update_id);\n    }\n  }\n\n}\n\nexports.Telegraf = Telegraf;","map":{"version":3,"names":["Object","defineProperty","exports","value","Telegraf","crypto","require","http","https","util","composer_1","compact_1","context_1","debug_1","webhook_1","polling_1","p_timeout_1","telegram_1","url_1","debug","default","DEFAULT_OPTIONS","telegram","handlerTimeout","contextType","always","x","anoop","Promise","resolve","Composer","constructor","token","options","context","handleError","err","ctx","process","exitCode","console","error","update","compactOptions","webhookReply","catch","handler","webhookCallback","path","res","handleUpdate","startPolling","allowedUpdates","polling","Polling","loop","updates","handleUpdates","startWebhook","hookPath","tlsOptions","port","host","cb","webhookCb","callback","req","webhookServer","createServer","listen","secretPathComponent","createHash","version","digest","launch","config","_a","_b","_c","botInfo","getMe","username","webhook","undefined","deleteWebhook","drop_pending_updates","dropPendingUpdates","domain","Error","startsWith","URL","setWebhook","allowed_updates","ip_address","ipAddress","max_connections","maxConnections","stop","reason","close","Array","isArray","TypeError","format","all","map","webhookResponse","update_id","botInfoCall","tg","TelegrafContext","assign","middleware","writableEnded","end"],"sources":["/Users/mazinabed/Desktop/testingbot/node_modules/telegraf/lib/telegraf.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Telegraf = void 0;\nconst crypto = require(\"crypto\");\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst util = require(\"util\");\nconst composer_1 = require(\"./composer\");\nconst compact_1 = require(\"./core/helpers/compact\");\nconst context_1 = require(\"./context\");\nconst debug_1 = require(\"debug\");\nconst webhook_1 = require(\"./core/network/webhook\");\nconst polling_1 = require(\"./core/network/polling\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst telegram_1 = require(\"./telegram\");\nconst url_1 = require(\"url\");\nconst debug = (0, debug_1.default)('telegraf:main');\nconst DEFAULT_OPTIONS = {\n    telegram: {},\n    handlerTimeout: 90000,\n    contextType: context_1.default,\n};\nfunction always(x) {\n    return () => x;\n}\nconst anoop = always(Promise.resolve());\nclass Telegraf extends composer_1.Composer {\n    constructor(token, options) {\n        super();\n        this.context = {};\n        this.handleError = (err, ctx) => {\n            // set exit code to emulate `warn-with-error-code` behavior of\n            // https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode\n            // to prevent a clean exit despite an error being thrown\n            process.exitCode = 1;\n            console.error('Unhandled error while processing', ctx.update);\n            throw err;\n        };\n        // @ts-expect-error Trust me, TS\n        this.options = {\n            ...DEFAULT_OPTIONS,\n            ...(0, compact_1.compactOptions)(options),\n        };\n        this.telegram = new telegram_1.default(token, this.options.telegram);\n        debug('Created a `Telegraf` instance');\n    }\n    get token() {\n        return this.telegram.token;\n    }\n    /** @deprecated use `ctx.telegram.webhookReply` */\n    set webhookReply(webhookReply) {\n        this.telegram.webhookReply = webhookReply;\n    }\n    get webhookReply() {\n        return this.telegram.webhookReply;\n    }\n    /**\n     * _Override_ error handling\n     */\n    catch(handler) {\n        this.handleError = handler;\n        return this;\n    }\n    webhookCallback(path = '/') {\n        return (0, webhook_1.default)(path, (update, res) => this.handleUpdate(update, res));\n    }\n    startPolling(allowedUpdates = []) {\n        this.polling = new polling_1.Polling(this.telegram, allowedUpdates);\n        this.polling.loop(async (updates) => {\n            await this.handleUpdates(updates);\n        });\n    }\n    startWebhook(hookPath, tlsOptions, port, host, cb) {\n        const webhookCb = this.webhookCallback(hookPath);\n        const callback = typeof cb === 'function'\n            ? (req, res) => webhookCb(req, res, () => cb(req, res))\n            : webhookCb;\n        this.webhookServer =\n            tlsOptions != null\n                ? https.createServer(tlsOptions, callback)\n                : http.createServer(callback);\n        this.webhookServer.listen(port, host, () => {\n            debug('Webhook listening on port: %s', port);\n        });\n        return this;\n    }\n    secretPathComponent() {\n        return crypto\n            .createHash('sha3-256')\n            .update(this.token)\n            .update(process.version) // salt\n            .digest('hex');\n    }\n    /**\n     * @see https://github.com/telegraf/telegraf/discussions/1344#discussioncomment-335700\n     */\n    async launch(config = {}) {\n        var _a, _b, _c;\n        debug('Connecting to Telegram');\n        (_a = this.botInfo) !== null && _a !== void 0 ? _a : (this.botInfo = await this.telegram.getMe());\n        debug(`Launching @${this.botInfo.username}`);\n        if (config.webhook === undefined) {\n            await this.telegram.deleteWebhook({\n                drop_pending_updates: config.dropPendingUpdates,\n            });\n            this.startPolling(config.allowedUpdates);\n            debug('Bot started with long polling');\n            return;\n        }\n        if (typeof config.webhook.domain !== 'string' &&\n            typeof config.webhook.hookPath !== 'string') {\n            throw new Error('Webhook domain or webhook path is required');\n        }\n        let domain = (_b = config.webhook.domain) !== null && _b !== void 0 ? _b : '';\n        if (domain.startsWith('https://') || domain.startsWith('http://')) {\n            domain = new url_1.URL(domain).host;\n        }\n        const hookPath = (_c = config.webhook.hookPath) !== null && _c !== void 0 ? _c : `/telegraf/${this.secretPathComponent()}`;\n        const { port, host, tlsOptions, cb } = config.webhook;\n        this.startWebhook(hookPath, tlsOptions, port, host, cb);\n        if (!domain) {\n            debug('Bot started with webhook');\n            return;\n        }\n        await this.telegram.setWebhook(`https://${domain}${hookPath}`, {\n            drop_pending_updates: config.dropPendingUpdates,\n            allowed_updates: config.allowedUpdates,\n            ip_address: config.webhook.ipAddress,\n            max_connections: config.webhook.maxConnections,\n        });\n        debug(`Bot started with webhook @ https://${domain}`);\n    }\n    stop(reason = 'unspecified') {\n        var _a, _b;\n        debug('Stopping bot... Reason:', reason);\n        // https://github.com/telegraf/telegraf/pull/1224#issuecomment-742693770\n        if (this.polling === undefined && this.webhookServer === undefined) {\n            throw new Error('Bot is not running!');\n        }\n        (_a = this.webhookServer) === null || _a === void 0 ? void 0 : _a.close();\n        (_b = this.polling) === null || _b === void 0 ? void 0 : _b.stop();\n    }\n    handleUpdates(updates) {\n        if (!Array.isArray(updates)) {\n            throw new TypeError(util.format('Updates must be an array, got', updates));\n        }\n        return Promise.all(updates.map((update) => this.handleUpdate(update)));\n    }\n    async handleUpdate(update, webhookResponse) {\n        var _a, _b;\n        (_a = this.botInfo) !== null && _a !== void 0 ? _a : (this.botInfo = (debug('Update %d is waiting for `botInfo` to be initialized', update.update_id),\n            await ((_b = this.botInfoCall) !== null && _b !== void 0 ? _b : (this.botInfoCall = this.telegram.getMe()))));\n        debug('Processing update', update.update_id);\n        const tg = new telegram_1.default(this.token, this.telegram.options, webhookResponse);\n        const TelegrafContext = this.options.contextType;\n        const ctx = new TelegrafContext(update, tg, this.botInfo);\n        Object.assign(ctx, this.context);\n        try {\n            await (0, p_timeout_1.default)(Promise.resolve(this.middleware()(ctx, anoop)), this.options.handlerTimeout);\n        }\n        catch (err) {\n            return await this.handleError(err, ctx);\n        }\n        finally {\n            if ((webhookResponse === null || webhookResponse === void 0 ? void 0 : webhookResponse.writableEnded) === false) {\n                webhookResponse.end();\n            }\n            debug('Finished processing update', update.update_id);\n        }\n    }\n}\nexports.Telegraf = Telegraf;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
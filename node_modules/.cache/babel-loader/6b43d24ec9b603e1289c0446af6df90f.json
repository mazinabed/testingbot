{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst debug_1 = require(\"debug\");\n\nconst util_1 = require(\"util\");\n\nconst error_1 = require(\"./error\");\n\nconst debug = (0, debug_1.default)('telegraf:polling');\nconst wait = (0, util_1.promisify)(setTimeout);\n\nfunction always(x) {\n  return () => x;\n}\n\nconst noop = always(Promise.resolve());\n\nclass Polling {\n  constructor(telegram, allowedUpdates) {\n    this.telegram = telegram;\n    this.allowedUpdates = allowedUpdates;\n    this.abortController = new abort_controller_1.default();\n    this.skipOffsetSync = false;\n    this.offset = 0;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    var _a, _b;\n\n    debug('Starting long polling');\n\n    do {\n      try {\n        const updates = await this.telegram.callApi('getUpdates', {\n          timeout: 50,\n          offset: this.offset,\n          allowed_updates: this.allowedUpdates\n        }, this.abortController);\n        const last = updates[updates.length - 1];\n\n        if (last !== undefined) {\n          this.offset = last.update_id + 1;\n        }\n\n        yield updates;\n      } catch (error) {\n        const err = error;\n        if (err.name === 'AbortError') return;\n\n        if (err.name === 'FetchError' || err instanceof error_1.TelegramError && err.code >= 500) {\n          const retryAfter = (_b = (_a = err.parameters) === null || _a === void 0 ? void 0 : _a.retry_after) !== null && _b !== void 0 ? _b : 5;\n          debug('Failed to fetch updates, retrying after %ds.', retryAfter, err);\n          await wait(retryAfter * 1000);\n          continue;\n        }\n\n        if (err instanceof error_1.TelegramError && ( // Unauthorized      Conflict\n        err.code === 401 || err.code === 409)) {\n          this.skipOffsetSync = true;\n          throw err;\n        }\n\n        throw err;\n      }\n    } while (!this.abortController.signal.aborted);\n  }\n\n  async syncUpdateOffset() {\n    if (this.skipOffsetSync) return;\n    debug('Syncing update offset...');\n    await this.telegram.callApi('getUpdates', {\n      offset: this.offset,\n      limit: 1\n    });\n  }\n\n  async loop(handleUpdates) {\n    if (this.abortController.signal.aborted) {\n      throw new Error('Polling instances must not be reused!');\n    }\n\n    try {\n      for await (const updates of this) {\n        await handleUpdates(updates);\n      }\n    } finally {\n      debug('Long polling stopped'); // prevent instance reuse\n\n      this.stop();\n      await this.syncUpdateOffset().catch(noop);\n    }\n  }\n\n  stop() {\n    this.abortController.abort();\n  }\n\n}\n\nexports.Polling = Polling;","map":{"version":3,"names":["Object","defineProperty","exports","value","Polling","abort_controller_1","require","debug_1","util_1","error_1","debug","default","wait","promisify","setTimeout","always","x","noop","Promise","resolve","constructor","telegram","allowedUpdates","abortController","skipOffsetSync","offset","Symbol","asyncIterator","_a","_b","updates","callApi","timeout","allowed_updates","last","length","undefined","update_id","error","err","name","TelegramError","code","retryAfter","parameters","retry_after","signal","aborted","syncUpdateOffset","limit","loop","handleUpdates","Error","stop","catch","abort"],"sources":["/Users/mazinabed/Desktop/testingbot/node_modules/telegraf/lib/core/network/polling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst debug_1 = require(\"debug\");\nconst util_1 = require(\"util\");\nconst error_1 = require(\"./error\");\nconst debug = (0, debug_1.default)('telegraf:polling');\nconst wait = (0, util_1.promisify)(setTimeout);\nfunction always(x) {\n    return () => x;\n}\nconst noop = always(Promise.resolve());\nclass Polling {\n    constructor(telegram, allowedUpdates) {\n        this.telegram = telegram;\n        this.allowedUpdates = allowedUpdates;\n        this.abortController = new abort_controller_1.default();\n        this.skipOffsetSync = false;\n        this.offset = 0;\n    }\n    async *[Symbol.asyncIterator]() {\n        var _a, _b;\n        debug('Starting long polling');\n        do {\n            try {\n                const updates = await this.telegram.callApi('getUpdates', {\n                    timeout: 50,\n                    offset: this.offset,\n                    allowed_updates: this.allowedUpdates,\n                }, this.abortController);\n                const last = updates[updates.length - 1];\n                if (last !== undefined) {\n                    this.offset = last.update_id + 1;\n                }\n                yield updates;\n            }\n            catch (error) {\n                const err = error;\n                if (err.name === 'AbortError')\n                    return;\n                if (err.name === 'FetchError' ||\n                    (err instanceof error_1.TelegramError && err.code >= 500)) {\n                    const retryAfter = (_b = (_a = err.parameters) === null || _a === void 0 ? void 0 : _a.retry_after) !== null && _b !== void 0 ? _b : 5;\n                    debug('Failed to fetch updates, retrying after %ds.', retryAfter, err);\n                    await wait(retryAfter * 1000);\n                    continue;\n                }\n                if (err instanceof error_1.TelegramError &&\n                    // Unauthorized      Conflict\n                    (err.code === 401 || err.code === 409)) {\n                    this.skipOffsetSync = true;\n                    throw err;\n                }\n                throw err;\n            }\n        } while (!this.abortController.signal.aborted);\n    }\n    async syncUpdateOffset() {\n        if (this.skipOffsetSync)\n            return;\n        debug('Syncing update offset...');\n        await this.telegram.callApi('getUpdates', { offset: this.offset, limit: 1 });\n    }\n    async loop(handleUpdates) {\n        if (this.abortController.signal.aborted) {\n            throw new Error('Polling instances must not be reused!');\n        }\n        try {\n            for await (const updates of this) {\n                await handleUpdates(updates);\n            }\n        }\n        finally {\n            debug('Long polling stopped');\n            // prevent instance reuse\n            this.stop();\n            await this.syncUpdateOffset().catch(noop);\n        }\n    }\n    stop() {\n        this.abortController.abort();\n    }\n}\nexports.Polling = Polling;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}